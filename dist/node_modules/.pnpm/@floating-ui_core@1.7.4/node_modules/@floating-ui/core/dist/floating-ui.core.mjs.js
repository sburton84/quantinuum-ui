import{evaluate as e,getPaddingObject as t,getAlignmentAxis as n,min as i,clamp as o,getAlignment as r,placements as l,getAlignmentSides as a,getSide as s,getSideAxis as f,getOppositePlacement as c,getExpandedPlacements as m,getOppositeAxisPlacements as d,rectToClientRect as u,max as g,getAxisLength as p,getOppositeAlignmentPlacement as h,sides as y,getOppositeAxis as w}from"../../../../../@floating-ui_utils@0.2.10/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs.js";export{rectToClientRect}from"../../../../../@floating-ui_utils@0.2.10/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs.js";function x(e,t,i){let{reference:o,floating:l}=e;const a=f(t),c=n(t),m=p(c),d=s(t),u="y"===a,g=o.x+o.width/2-l.width/2,h=o.y+o.height/2-l.height/2,y=o[m]/2-l[m]/2;let w;switch(d){case"top":w={x:g,y:o.y-l.height};break;case"bottom":w={x:g,y:o.y+o.height};break;case"right":w={x:o.x+o.width,y:h};break;case"left":w={x:o.x-l.width,y:h};break;default:w={x:o.x,y:o.y}}switch(r(t)){case"start":w[c]-=y*(i&&u?-1:1);break;case"end":w[c]+=y*(i&&u?-1:1)}return w}async function v(n,i){var o;void 0===i&&(i={});const{x:r,y:l,platform:a,rects:s,elements:f,strategy:c}=n,{boundary:m="clippingAncestors",rootBoundary:d="viewport",elementContext:g="floating",altBoundary:p=!1,padding:h=0}=e(i,n),y=t(h),w=f[p?"floating"===g?"reference":"floating":g],x=u(await a.getClippingRect({element:null==(o=await(null==a.isElement?void 0:a.isElement(w)))||o?w:w.contextElement||await(null==a.getDocumentElement?void 0:a.getDocumentElement(f.floating)),boundary:m,rootBoundary:d,strategy:c})),v="floating"===g?{x:r,y:l,width:s.floating.width,height:s.floating.height}:s.reference,b=await(null==a.getOffsetParent?void 0:a.getOffsetParent(f.floating)),A=await(null==a.isElement?void 0:a.isElement(b))&&await(null==a.getScale?void 0:a.getScale(b))||{x:1,y:1},R=u(a.convertOffsetParentRelativeRectToViewportRelativeRect?await a.convertOffsetParentRelativeRectToViewportRelativeRect({elements:f,rect:v,offsetParent:b,strategy:c}):v);return{top:(x.top-R.top+y.top)/A.y,bottom:(R.bottom-x.bottom+y.bottom)/A.y,left:(x.left-R.left+y.left)/A.x,right:(R.right-x.right+y.right)/A.x}}const b=async(e,t,n)=>{const{placement:i="bottom",strategy:o="absolute",middleware:r=[],platform:l}=n,a=r.filter(Boolean),s=await(null==l.isRTL?void 0:l.isRTL(t));let f=await l.getElementRects({reference:e,floating:t,strategy:o}),{x:c,y:m}=x(f,i,s),d=i,u={},g=0;for(let n=0;n<a.length;n++){var p;const{name:r,fn:h}=a[n],{x:y,y:w,data:b,reset:A}=await h({x:c,y:m,initialPlacement:i,placement:d,strategy:o,middlewareData:u,rects:f,platform:{...l,detectOverflow:null!=(p=l.detectOverflow)?p:v},elements:{reference:e,floating:t}});c=null!=y?y:c,m=null!=w?w:m,u={...u,[r]:{...u[r],...b}},A&&g<=50&&(g++,"object"==typeof A&&(A.placement&&(d=A.placement),A.rects&&(f=!0===A.rects?await l.getElementRects({reference:e,floating:t,strategy:o}):A.rects),({x:c,y:m}=x(f,d,s))),n=-1)}return{x:c,y:m,placement:d,strategy:o,middlewareData:u}},A=l=>({name:"arrow",options:l,async fn(a){const{x:s,y:f,placement:c,rects:m,platform:d,elements:u,middlewareData:g}=a,{element:h,padding:y=0}=e(l,a)||{};if(null==h)return{};const w=t(y),x={x:s,y:f},v=n(c),b=p(v),A=await d.getDimensions(h),R="y"===v,O=R?"top":"left",D=R?"bottom":"right",P=R?"clientHeight":"clientWidth",T=m.reference[b]+m.reference[v]-x[v]-m.floating[b],E=x[v]-m.reference[v],L=await(null==d.getOffsetParent?void 0:d.getOffsetParent(h));let k=L?L[P]:0;k&&await(null==d.isElement?void 0:d.isElement(L))||(k=u.floating[P]||m.floating[b]);const C=T/2-E/2,B=k/2-A[b]/2-1,H=i(w[O],B),j=i(w[D],B),S=H,_=k-A[b]-j,F=k/2-A[b]/2+C,V=o(S,F,_),W=!g.arrow&&null!=r(c)&&F!==V&&m.reference[b]/2-(F<S?H:j)-A[b]/2<0,z=W?F<S?F-S:F-_:0;return{[v]:x[v]+z,data:{[v]:V,centerOffset:F-V-z,...W&&{alignmentOffset:z}},reset:W}}});const R=function(t){return void 0===t&&(t={}),{name:"autoPlacement",options:t,async fn(n){var i,o,f;const{rects:c,middlewareData:m,placement:d,platform:u,elements:g}=n,{crossAxis:p=!1,alignment:y,allowedPlacements:w=l,autoAlignment:x=!0,...v}=e(t,n),b=void 0!==y||w===l?function(e,t,n){return(e?[...n.filter(t=>r(t)===e),...n.filter(t=>r(t)!==e)]:n.filter(e=>s(e)===e)).filter(n=>!e||r(n)===e||!!t&&h(n)!==n)}(y||null,x,w):w,A=await u.detectOverflow(n,v),R=(null==(i=m.autoPlacement)?void 0:i.index)||0,O=b[R];if(null==O)return{};const D=a(O,c,await(null==u.isRTL?void 0:u.isRTL(g.floating)));if(d!==O)return{reset:{placement:b[0]}};const P=[A[s(O)],A[D[0]],A[D[1]]],T=[...(null==(o=m.autoPlacement)?void 0:o.overflows)||[],{placement:O,overflows:P}],E=b[R+1];if(E)return{data:{index:R+1,overflows:T},reset:{placement:E}};const L=T.map(e=>{const t=r(e.placement);return[e.placement,t&&p?e.overflows.slice(0,2).reduce((e,t)=>e+t,0):e.overflows[0],e.overflows]}).sort((e,t)=>e[1]-t[1]),k=(null==(f=L.filter(e=>e[2].slice(0,r(e[0])?2:3).every(e=>e<=0))[0])?void 0:f[0])||L[0][0];return k!==d?{data:{index:R+1,overflows:T},reset:{placement:k}}:{}}}},O=function(t){return void 0===t&&(t={}),{name:"flip",options:t,async fn(n){var i,o;const{placement:r,middlewareData:l,rects:u,initialPlacement:g,platform:p,elements:h}=n,{mainAxis:y=!0,crossAxis:w=!0,fallbackPlacements:x,fallbackStrategy:v="bestFit",fallbackAxisSideDirection:b="none",flipAlignment:A=!0,...R}=e(t,n);if(null!=(i=l.arrow)&&i.alignmentOffset)return{};const O=s(r),D=f(g),P=s(g)===g,T=await(null==p.isRTL?void 0:p.isRTL(h.floating)),E=x||(P||!A?[c(g)]:m(g)),L="none"!==b;!x&&L&&E.push(...d(g,A,b,T));const k=[g,...E],C=await p.detectOverflow(n,R),B=[];let H=(null==(o=l.flip)?void 0:o.overflows)||[];if(y&&B.push(C[O]),w){const e=a(r,u,T);B.push(C[e[0]],C[e[1]])}if(H=[...H,{placement:r,overflows:B}],!B.every(e=>e<=0)){var j,S;const e=((null==(j=l.flip)?void 0:j.index)||0)+1,t=k[e];if(t){if(!("alignment"===w&&D!==f(t))||H.every(e=>f(e.placement)!==D||e.overflows[0]>0))return{data:{index:e,overflows:H},reset:{placement:t}}}let n=null==(S=H.filter(e=>e.overflows[0]<=0).sort((e,t)=>e.overflows[1]-t.overflows[1])[0])?void 0:S.placement;if(!n)switch(v){case"bestFit":{var _;const e=null==(_=H.filter(e=>{if(L){const t=f(e.placement);return t===D||"y"===t}return!0}).map(e=>[e.placement,e.overflows.filter(e=>e>0).reduce((e,t)=>e+t,0)]).sort((e,t)=>e[1]-t[1])[0])?void 0:_[0];e&&(n=e);break}case"initialPlacement":n=g}if(r!==n)return{reset:{placement:n}}}return{}}}};function D(e,t){return{top:e.top-t.height,right:e.right-t.width,bottom:e.bottom-t.height,left:e.left-t.width}}function P(e){return y.some(t=>e[t]>=0)}const T=function(t){return void 0===t&&(t={}),{name:"hide",options:t,async fn(n){const{rects:i,platform:o}=n,{strategy:r="referenceHidden",...l}=e(t,n);switch(r){case"referenceHidden":{const e=D(await o.detectOverflow(n,{...l,elementContext:"reference"}),i.reference);return{data:{referenceHiddenOffsets:e,referenceHidden:P(e)}}}case"escaped":{const e=D(await o.detectOverflow(n,{...l,altBoundary:!0}),i.floating);return{data:{escapedOffsets:e,escaped:P(e)}}}default:return{}}}}};function E(e){const t=i(...e.map(e=>e.left)),n=i(...e.map(e=>e.top));return{x:t,y:n,width:g(...e.map(e=>e.right))-t,height:g(...e.map(e=>e.bottom))-n}}const L=function(n){return void 0===n&&(n={}),{name:"inline",options:n,async fn(o){const{placement:r,elements:l,rects:a,platform:c,strategy:m}=o,{padding:d=2,x:p,y:h}=e(n,o),y=Array.from(await(null==c.getClientRects?void 0:c.getClientRects(l.reference))||[]),w=function(e){const t=e.slice().sort((e,t)=>e.y-t.y),n=[];let i=null;for(let e=0;e<t.length;e++){const o=t[e];!i||o.y-i.y>i.height/2?n.push([o]):n[n.length-1].push(o),i=o}return n.map(e=>u(E(e)))}(y),x=u(E(y)),v=t(d);const b=await c.getElementRects({reference:{getBoundingClientRect:function(){if(2===w.length&&w[0].left>w[1].right&&null!=p&&null!=h)return w.find(e=>p>e.left-v.left&&p<e.right+v.right&&h>e.top-v.top&&h<e.bottom+v.bottom)||x;if(w.length>=2){if("y"===f(r)){const e=w[0],t=w[w.length-1],n="top"===s(r),i=e.top,o=t.bottom,l=n?e.left:t.left,a=n?e.right:t.right;return{top:i,bottom:o,left:l,right:a,width:a-l,height:o-i,x:l,y:i}}const e="left"===s(r),t=g(...w.map(e=>e.right)),n=i(...w.map(e=>e.left)),o=w.filter(i=>e?i.left===n:i.right===t),l=o[0].top,a=o[o.length-1].bottom;return{top:l,bottom:a,left:n,right:t,width:t-n,height:a-l,x:n,y:l}}return x}},floating:l.floating,strategy:m});return a.reference.x!==b.reference.x||a.reference.y!==b.reference.y||a.reference.width!==b.reference.width||a.reference.height!==b.reference.height?{reset:{rects:b}}:{}}}},k=new Set(["left","top"]);const C=function(t){return void 0===t&&(t=0),{name:"offset",options:t,async fn(n){var i,o;const{x:l,y:a,placement:c,middlewareData:m}=n,d=await async function(t,n){const{placement:i,platform:o,elements:l}=t,a=await(null==o.isRTL?void 0:o.isRTL(l.floating)),c=s(i),m=r(i),d="y"===f(i),u=k.has(c)?-1:1,g=a&&d?-1:1,p=e(n,t);let{mainAxis:h,crossAxis:y,alignmentAxis:w}="number"==typeof p?{mainAxis:p,crossAxis:0,alignmentAxis:null}:{mainAxis:p.mainAxis||0,crossAxis:p.crossAxis||0,alignmentAxis:p.alignmentAxis};return m&&"number"==typeof w&&(y="end"===m?-1*w:w),d?{x:y*g,y:h*u}:{x:h*u,y:y*g}}(n,t);return c===(null==(i=m.offset)?void 0:i.placement)&&null!=(o=m.arrow)&&o.alignmentOffset?{}:{x:l+d.x,y:a+d.y,data:{...d,placement:c}}}}},B=function(t){return void 0===t&&(t={}),{name:"shift",options:t,async fn(n){const{x:i,y:r,placement:l,platform:a}=n,{mainAxis:c=!0,crossAxis:m=!1,limiter:d={fn:e=>{let{x:t,y:n}=e;return{x:t,y:n}}},...u}=e(t,n),g={x:i,y:r},p=await a.detectOverflow(n,u),h=f(s(l)),y=w(h);let x=g[y],v=g[h];if(c){const e="y"===y?"bottom":"right",t=x+p["y"===y?"top":"left"],n=x-p[e];x=o(t,x,n)}if(m){const e="y"===h?"bottom":"right",t=v+p["y"===h?"top":"left"],n=v-p[e];v=o(t,v,n)}const b=d.fn({...n,[y]:x,[h]:v});return{...b,data:{x:b.x-i,y:b.y-r,enabled:{[y]:c,[h]:m}}}}}},H=function(t){return void 0===t&&(t={}),{options:t,fn(n){const{x:i,y:o,placement:r,rects:l,middlewareData:a}=n,{offset:c=0,mainAxis:m=!0,crossAxis:d=!0}=e(t,n),u={x:i,y:o},g=f(r),p=w(g);let h=u[p],y=u[g];const x=e(c,n),v="number"==typeof x?{mainAxis:x,crossAxis:0}:{mainAxis:0,crossAxis:0,...x};if(m){const e="y"===p?"height":"width",t=l.reference[p]-l.floating[e]+v.mainAxis,n=l.reference[p]+l.reference[e]-v.mainAxis;h<t?h=t:h>n&&(h=n)}if(d){var b,A;const e="y"===p?"width":"height",t=k.has(s(r)),n=l.reference[g]-l.floating[e]+(t&&(null==(b=a.offset)?void 0:b[g])||0)+(t?0:v.crossAxis),i=l.reference[g]+l.reference[e]+(t?0:(null==(A=a.offset)?void 0:A[g])||0)-(t?v.crossAxis:0);y<n?y=n:y>i&&(y=i)}return{[p]:h,[g]:y}}}},j=function(t){return void 0===t&&(t={}),{name:"size",options:t,async fn(n){var o,l;const{placement:a,rects:c,platform:m,elements:d}=n,{apply:u=()=>{},...p}=e(t,n),h=await m.detectOverflow(n,p),y=s(a),w=r(a),x="y"===f(a),{width:v,height:b}=c.floating;let A,R;"top"===y||"bottom"===y?(A=y,R=w===(await(null==m.isRTL?void 0:m.isRTL(d.floating))?"start":"end")?"left":"right"):(R=y,A="end"===w?"top":"bottom");const O=b-h.top-h.bottom,D=v-h.left-h.right,P=i(b-h[A],O),T=i(v-h[R],D),E=!n.middlewareData.shift;let L=P,k=T;if(null!=(o=n.middlewareData.shift)&&o.enabled.x&&(k=D),null!=(l=n.middlewareData.shift)&&l.enabled.y&&(L=O),E&&!w){const e=g(h.left,0),t=g(h.right,0),n=g(h.top,0),i=g(h.bottom,0);x?k=v-2*(0!==e||0!==t?e+t:g(h.left,h.right)):L=b-2*(0!==n||0!==i?n+i:g(h.top,h.bottom))}await u({...n,availableWidth:k,availableHeight:L});const C=await m.getDimensions(d.floating);return v!==C.width||b!==C.height?{reset:{rects:!0}}:{}}}};export{A as arrow,R as autoPlacement,b as computePosition,v as detectOverflow,O as flip,T as hide,L as inline,H as limitShift,C as offset,B as shift,j as size};
//# sourceMappingURL=floating-ui.core.mjs.js.map
